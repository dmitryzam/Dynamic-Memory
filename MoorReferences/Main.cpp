#include<iostream>
#include<cstdlib>
#include<ctime>
// Урок 47. МОДУЛЬ 6. Динамическая память (Dynamic memory).
// К статической памяти относятся - переменные, массивы, функции, ссылки и указатели.
// Суть динамич. памяти в том, что ее участки выделяются динамически, по необходимости. Их работа медленее, чем статической.
// Элементы статич. памяти выделяется мгновенно....

// Заполненние массива случайными числами:
template <typename T>
void fill_arr(T arr[], const int length, int left, int right) {
	srand(time(NULL));
	for (int i = 0; i < length; i++)
		arr[i] = rand() % (right - left) + left;
}
// Вывод массива:
template <typename T>
void print_arr(T arr[], const int length) {
	std::cout << "{ ";
	for (int i = 0; i < length; i++)
		std::cout << arr[i] << ", ";
	std::cout << "\b\b }\n";
}
// Функция задачи 1:
template <typename T>
void arr_app(T*& arr, int length, int num) {
	if (num <= 0)						// Шаг 0. Защита от лишних действий.
		return;
	// Мы создаем новый массив нужной длины. Мы копируем содержимое первого массива во второй. Удаляем первый массив. И перенаправляем указатель на второй массив.
	T* tmp = new T[length + num]{};		// Шаг 1. Выделение памяти под новый массив и заполняем его полностью нулями.
	for (int i = 0; i < length; i++)	// Шаг 2. Копирование значений старого массива в новый.
		tmp[i] = arr[i];
	delete[] arr;						// Шаг 3. Освобождение памяти, выделенной под старый массив.
	arr = tmp;							// Шаг 4. Перенаправление указателя arr на новый динамич. массив 
}

template <typename T>
void arr_del(T*& arr, int length, int num) {
	if (num <= 0)
		return;
	if (num >= length) {
		delete[] arr;
		arr = nullptr;
		return;
	}
	T* tmp = new T[length - num];
	for (int i = 0; i < length - num; i++)
		tmp[i] = arr[i];
	delete[] arr;
	arr = tmp;
}


int main() {
	setlocale(LC_ALL, "RU");
	int n;

	// Выделение динамической памяти:
	
	int* pointer = new int;	// создаем указатель. new - это оператор. Выделение участка динамической памяти размером в тип int (4 б).
	// указатель pointer находится в статич. памяти. Участок динамич. памяти не имеет имени. Ссылку можно присвоить к этой ячейке динамич. памяти.

	*pointer = 7;	// записали значение 7 в область динамич. памяти.
	std::cout << "pointer = " << pointer << std::endl;
	std::cout << "*pointer = " << *pointer << std::endl;

	// см. комментарии строки 21.
	delete pointer;	// освобождение памяти, выделенной динамически.
	pointer = nullptr;	// указаетль делаем нейтральным.

	if (pointer == nullptr)
		pointer = new int;	// выделяем новый участок динамич. памяти и направляем указатель на эту ячейку и предыдущая ячейка памяти перестает существовать,
	// то есть происходит утечка памяти (не сможем эту область памяти использовать, а также другие программы также не смогут использовать эту область памяти)
	
	*pointer = 15;
	std::cout << "pointer = " << pointer << std::endl;
	std::cout << "*pointer = " << *pointer << std::endl;

	// Утечка памяти - явление, когда в связи с небрежным применением памяти остаются значения, не связанные с какими-либо указателями. 
	// Данные значения "блокируют" ячейки памяти и не дают другим программам с ними взаимодействовать.
	// правилом хорошего тона необходимо удалять (освобождать) все области динамич. памяти, то есть использовать команду delete.
	
	// Одномерные Динамические массивы:
	
	std::cout << "Введите длину массива -> ";
	int dsize;
	std::cin >> dsize;
	int* darr = new int[dsize];	// создадим динамич. массив, который указан на участок динамич. памяти, размером на три ячейки типа int.
	// int arr[dsize];	// будет ошибка для обычного массива, так как он находится в статич. памяти.
	fill_arr(darr, dsize, 1, 11);
	std::cout << "Массив:\n";
	print_arr(darr, dsize);

	delete[] darr;	// в таком случае будет освобождаться весь массив (размер указывать не обязательно)
	
	// Области прменения динамических массивов:
	// 1. Размер массива неизвестен на этапе написания кода;
	// 2. Размер массива должен иметь возможность измениться;
	// 3. Реализация сложных структур данных. (Например: строки, структуры)
	

	// Двумерные динамические массивы:
	
	int rows = 5, cols = 4;
	//int* mx = new int[rows][cols] // не работает. Синтаксис к двумерным динамич. массивам не применим.
	int** mx = new int* [rows];		// мы создали массив указателей.
	for (int i = 0; i < rows; i++)	// в цикле for создаем ряды массива.
		mx[i] = new int[cols];

	// попробуем удалить двумерный массив:
	for (int i = 0; i < rows; i++)
		delete[] mx[i];		// сначала удаляем ряды массива.
	delete[] mx;			// потом удаляем массив указателей.
	

	// Задача 1. Увеличение размера массива c помощью функции.
	
	std::cout << "Задача 1.\nВведите размер массива -> ";
	int size1;
	std::cin >> size1;
	int* arr1 = new int[size1];
	fill_arr(arr1, size1, 10, 21);
	std::cout << "Изначальный массив:\n";
	print_arr(arr1, size1);
	std::cout << "Введите кол-во новых элементов -> ";
	std::cin >> n;
	arr_app(arr1, size1, n);
	if (n > 0)
		size1 += n;
	std::cout << "Итоговый массив:\n";
	print_arr(arr1, size1);
	delete[] arr1;
	
	// Задача 2. Уменьшение размера массива.
	std::cout << "Задача 2.\nВведите размер массива -> ";
	int size2;
	std::cin >> size2;
	int* arr2 = new int[size2];
	fill_arr(arr2, size2, 10, 21);
	std::cout << "Изначальный массив:\n";
	print_arr(arr2, size2);
	std::cout << "Введите кол-во элементов для удаления -> ";
	std::cin >> n;
	arr_del(arr2, size2, n);
	if (n >= size2)
		size2 = 0;
	else
		if (n > 0)
			size2 -= n;
	std::cout << "Итоговый массив:\n";
	print_arr(arr2, size2);
	delete[] arr2;

	return 0;
}